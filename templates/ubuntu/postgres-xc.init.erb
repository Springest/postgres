#!/bin/sh
set -e

### BEGIN INIT INFO
# Provides:   postgres-xc
# Required-Start: $local_fs $remote_fs $network $time
# Required-Stop:  $local_fs $remote_fs $network $time
# Should-Start:   $syslog
# Should-Stop:    $syslog
# Default-Start:  2 3 4 5
# Default-Stop:   0 1 6
# Short-Description:  Postgres-XC RDBMS server
### END INIT INFO

PGXC_GTM_ROOT=/etc/postgres-xc/gtm
PGXC_COORDINATOR_ROOT=/etc/postgres-xc/coordinator
PGXC_DATANODE_ROOT=/etc/postgres-xc/datanode
PGXC_DATA=/var/lib/postgres-xc
PGXC_LOG=/var/log/postgres-xc
PGXC_RUN=/var/run/postgresql

. /lib/lsb/init-functions

# create socket directory
[ -d $PGXC_RUN ] || mkdir -p $PGXC_RUN

chown postgres-xc.postgres-xc $PGXC_RUN
chmod 2775 $PGXC_RUN

check_if_running()
{
  status=0
  case "$1" in
    gtm)
      pidfile=gtm.pid
      sleep 2
      ;;
    postgres)
      pidfile=postmaster.pid
      confport=`grep -si '^port *=' $PGXC_DATA/$2/postgresql.conf | cut -f2 -d= | sed -e 's/#.*$//' -e 's/ //g'`
      port=${confport:=5432}

      # wait for server to come up, but no more than 10 seconds
      i=1
            while [ ! -S $PGXC_RUN/.s.PGSQL.$port ]; do
                    i=$((i+1))
                    sleep 1
                    [ $i -gt 10 ] && break
            done
      ;;
  esac

  # check if it is really running
  if [ -r $PGXC_DATA/$2/$pidfile ]; then
    PID=`head -n 1 $PGXC_DATA/$2/$pidfile` || true
    if [ -z "$PID" ]; then
      status=1
    else
      [ "`ps h -o comm -p $PID`" != $1 ] && status=1
    fi
  else
    status=1
  fi
  return 0
}

startup()
{
  status=0
  log_daemon_msg "Starting Postgres-XC global transaction management daemons"
  for i in `ls $PGXC_GTM_ROOT`; do
    if [ $status -eq 0 -a -f $PGXC_GTM_ROOT/$i/run ]; then
      ERRMSG=$(start-stop-daemon -c postgres-xc --start --exec /usr/bin/gtm_ctl -- start -Z gtm -D $PGXC_DATA/$i -l $PGXC_LOG/gtm.log 2>&1) || status=$?
      log_progress_msg $i
      [ $status -eq 0 ] && check_if_running gtm $i
    fi
  done
  log_end_msg $status

  log_daemon_msg "Starting Postgres-XC coordinators"
  for i in `ls $PGXC_COORDINATOR_ROOT/`; do
    if [ $status -eq 0 -a -f $PGXC_COORDINATOR_ROOT/$i/run ]; then
      ERRMSG=$(start-stop-daemon -c postgres-xc --start --exec /usr/bin/pg_ctl -- start -Z coordinator -D $PGXC_DATA/$i -l $PGXC_LOG/coordinator.log 2>&1) || status=$?
      log_progress_msg $i
      [ $status -eq 0 ] && check_if_running postgres $i
    fi
  done
  log_end_msg $status

  log_daemon_msg "Starting Postgres-XC datanodes"
  for i in `ls $PGXC_DATANODE_ROOT/`; do
    if [ $status -eq 0 -a -f $PGXC_DATANODE_ROOT/$i/run ]; then
      ERRMSG=$(start-stop-daemon -c postgres-xc --start --exec /usr/bin/pg_ctl -- start -Z datanode -D $PGXC_DATA/$i -l $PGXC_LOG/datanode.log 2>&1) || status=$?
      log_progress_msg $i
      [ $status -eq 0 ] && check_if_running postgres $i
    fi
  done
  log_end_msg $status
}

do_ctl()
{
  status=0
  [ $2 != "quiet" ] && log_daemon_msg "$2 Postgres-XC datanodes"
  for i in `ls $PGXC_DATANODE_ROOT/`; do
    if [ -f $PGXC_DATANODE_ROOT/$i/run ]; then
      ERRMSG=$(start-stop-daemon -c postgres-xc --start --exec /usr/bin/pg_ctl -- $1 -Z datanode -D $PGXC_DATA/$i -l $PGXC_LOG/datanode.log 2>&1) || status=$?
      log_progress_msg $i
    fi
  done
  [ $2 != "quiet" ] && log_end_msg $status

  [ $2 != "quiet" ] && log_daemon_msg "$2 Postgres-XC coordinators"
  for i in `ls $PGXC_COORDINATOR_ROOT/`; do
    if [ -f $PGXC_COORDINATOR_ROOT/$i/run ]; then
      ERRMSG=$(start-stop-daemon -c postgres-xc --start --exec /usr/bin/pg_ctl -- $1 -Z coordinator -D $PGXC_DATA/$i -l $PGXC_LOG/coordinator.log 2>&1) || status=$?
      log_progress_msg $i
    fi
  done
  [ $2 != "quiet" ] && log_end_msg $status

  if [ $1 != "reload" ]; then
    [ $2 != "quiet" ] && log_daemon_msg "$2 Postgres-XC global transaction management daemons"
    for i in `ls $PGXC_GTM_ROOT`; do
      if [ -f $PGXC_GTM_ROOT/$i/run ]; then
        ERRMSG=$(start-stop-daemon -c postgres-xc --start --exec /usr/bin/gtm_ctl -- $1 -Z gtm -D $PGXC_DATA/$i -l $PGXC_LOG/gtm.log  2>&1) || status=$?
        log_progress_msg $i
      fi
    done
    [ $2 != "quiet" ] && log_end_msg $status
  fi
}

case "$1" in
    start)
  startup
  ;;
    restart)
  do_ctl restart Restarting
        ;;
    status)
  do_ctl status quiet
        ;;
    stop)
  do_ctl stop Stopping
        ;;
    reload)
  do_ctl reload Reloading
  ;;
    force-reload)
  $0 restart
        ;;
    *)
        echo "Usage: $0 {start|stop|restart|reload|force-reload|status}"
        exit 1
        ;;
esac

exit 0
